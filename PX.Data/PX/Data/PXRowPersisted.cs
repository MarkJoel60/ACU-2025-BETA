// Decompiled with JetBrains decompiler
// Type: PX.Data.PXRowPersisted
// Assembly: PX.Data, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
// MVID: 2A82D21C-DAFC-4371-ACE9-BAD417AC5A62
// Assembly location: D:\tmp\2025 R2 DLLs\PX.Data.dll
// XML documentation location: D:\tmp\2025 R2 DLLs\PX.Data.xml

#nullable disable
namespace PX.Data;

/// <summary>
/// The delegate for the <tt>RowPersisted</tt> event.
/// </summary>
/// <param name="sender">Required. The cache object that raised the event.</param>
/// <param name="e">Required. The instance of the <see cref="T:PX.Data.PXRowPersistedEventArgs">PXRowPersistedEventArgs</see> type
/// that holds data for the <tt>RowPersisted</tt> event.</param>
/// <remarks>
///   <para>The <tt>RowPersisted</tt> event is generated in the process of committing changes to the database
///   for every data record whose status is <tt>Inserted</tt>, <tt>Updated</tt>,
/// or <tt>Deleted</tt>. The <tt>RowPersisted</tt> event is generated in the following cases:</para>
///   <list type="bullet">
///     <item><description>When the data record has been committed to the database and the status of the transaction scope
///     (indicated in the <tt>e.TranStatus</tt> field) is <tt>Open</tt></description></item>
///     <item><description>When the status of the transaction scope has been changed to <tt>Completed</tt>, indicating successful committing,
///     or <tt>Aborted</tt>, indicating that a database error has occurred and changes to the database have been dropped</description></item>
///   </list>
///   <para>The <tt>Actions.PressSave()</tt> method of the business logic controller (graph)
///   initiates the committing of changes to a database. While processing this method,
/// the Acumatica data access layer commits first every inserted data record, then every updated data record,
/// and finally every deleted data record.</para>
///   <para>Avoid executing additional BQL statements in a
///     <tt>RowPersisted</tt> event handler when the status of the transaction scope is <tt>Open</tt>.
///     When the <tt>RowPersisted</tt> event is raised with this status, the associated transaction scope is busy saving the changes,
///     and any other operation performed within this transaction scope may cause performance degradation and deadlocks.</para>
///   <para>The <tt>RowPersisted</tt> event handler is used to perform the following actions:</para>
///   <list type="bullet">
///     <item><description>Retrieval of data generated by the database.</description></item>
///     <item><description>Restoring of data access class (DAC) field values if the status of the transaction scope
///     is <tt>Aborted</tt> indicating that changes have not been saved. Note that in this case
///     the DAC fields do not revert to any previous state automatically but are left
///     by the Acumatica data access layer in the state they were in before
///     the committing was initiated.</description></item>
///     <item><description>Validation of the data record while committing it to the database.</description></item>
///   </list>
///   <para>The following execution order is used for the <tt>RowPersisted</tt> event handlers:</para>
///   <list type="number">
///     <item><description>Attribute event handlers are executed.</description></item>
///     <item><description>Graph event handlers are executed.</description></item>
///   </list>
/// </remarks>
/// <example>
/// <para>
/// According to the naming convention for graph event handlers in Acumatica Framework,
/// the classic event handler has the following signature.
/// </para>
/// <code>
/// protected virtual void DACName_RowPersisted(PXCache sender,
///                                             PXRowPersistedEventArgs e)
/// {
///     ...
/// }
/// </code>
/// </example>
/// <example>
/// <para>
/// The following code uses the redefinition of the attribute method
/// to retrieve data generated by the database.
/// </para>
/// <code>
/// [AttributeUsage(AttributeTargets.Property | AttributeTargets.Parameter |
///                 AttributeTargets.Class | AttributeTargets.Method)]
/// public class PXDBIdentityAttribute : PXDBFieldAttribute,
///                                      IPXFieldDefaultingSubscriber,
///                                      IPXRowSelectingSubscriber,
///                                      IPXCommandPreparingSubscriber,
///                                      IPXFieldUpdatingSubscriber,
///                                      IPXFieldSelectingSubscriber,
///                                      IPXRowPersistedSubscriber,
///                                      IPXFieldVerifyingSubscriber
/// {
///     ...
/// 
///     public virtual void RowPersisted(PXCache sender,
///                                      PXRowPersistedEventArgs e)
///     {
///         if ((e.Operation &amp; PXDBOperation.Command) == PXDBOperation.Insert)
///         {
///             if (e.TranStatus == PXTranStatus.Open)
///             {
///                 if (_KeyToAbort == null)
///                     _KeyToAbort = (int?)sender.GetValue(e.Row, _FieldOrdinal);
///                 if (_KeyToAbort &lt; 0)
///                 {
///                     int? id =
///                         Convert.ToInt32(PXDatabase.SelectIdentity(_BqlTable, _FieldName));
///                     if ((id ?? 0m) == 0m)
///                     {
///                         PXDataField[] pars =
///                             new PXDataField[sender.Keys.Count + 1];
///                         pars[0] = new PXDataField(_DatabaseFieldName);
///                         for (int i = 0; i &lt; sender.Keys.Count; i++)
///                         {
///                             string name = sender.Keys[i];
///                             PXCommandPreparingEventArgs.
///                                 FieldDescription description = null;
///                             sender.RaiseCommandPreparing(
///                                 name, e.Row,
///                                 sender.GetValue(e.Row, name),
///                                 PXDBOperation.Select,
///                                 _BqlTable, out description);
///                             if (description != null &amp;&amp;
///                                     description.Expr != null &amp;&amp;
///                                 description.IsRestriction)
///                             {
///                                 pars[i + 1] = new PXDataFieldValue(
///                                     description.Expr,
///                                     description.DataType,
///                                     description.DataLength,
///                                     description.DataValue);
///                             }
///                         }
///                         using (PXDataRecord record =
///                             PXDatabase.SelectSingle(_BqlTable, pars))
///                         {
///                             if (record != null)
///                                 id = record.GetInt32(0);
///                         }
///                     }
///                     sender.SetValue(e.Row, _FieldOrdinal, id);
///                 }
///                 else
///                     _KeyToAbort = null;
///             }
///             else if (e.TranStatus == PXTranStatus.Aborted &amp;&amp;
///                      _KeyToAbort != null)
///             {
///                 sender.SetValue(e.Row, _FieldOrdinal, _KeyToAbort);
///                 _KeyToAbort = null;
///             }
///         }
///     }
/// 
///     ...
/// }</code>
/// </example>
/// <example>
/// <para>
/// The following code uses a redefinition of the attribute method
/// to restore the values of a DAC field if the commitment failed,
/// which results in the Aborted status of the transaction scope.
/// </para>
/// <code>
/// public class AddressRevisionIDAttribute : PXEventSubscriberAttribute,
///                                           IPXRowPersistingSubscriber,
///                                           IPXRowPersistedSubscriber
/// {
///     ...
/// 
///     public virtual void RowPersisted(PXCache sender,
///                                      PXRowPersistedEventArgs e)
///     {
///         if (e.TranStatus == PXTranStatus.Aborted &amp;&amp;
///             (e.Operation == PXDBOperation.Insert || e.Operation ==
///              PXDBOperation.Update))
///         {
///             int? revision = (int?)sender.GetValue(e.Row, _FieldOrdinal);
///             revision--;
///             sender.SetValue(e.Row, _FieldOrdinal, revision);
///         }
///     }
/// 
///     ...
/// }
/// </code>
/// </example>
public delegate void PXRowPersisted(PXCache sender, PXRowPersistedEventArgs e);
